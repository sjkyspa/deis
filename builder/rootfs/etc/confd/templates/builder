#!/usr/bin/env bash
#
# builder hook called on every git receive-pack
# NOTE: this script must be run as root (for docker access)
#
set -eo pipefail

puts_red_f() {
  while read data; do
    echo $'\033[0;31m'"      $data" $'\033[0m'
  done
}

puts_green() {
  echo $'\033[0;32m'"      $@" $'\033[0m'
}

on_exit() {
    last_status=$?
    if [ "$last_status" != "0" ]; then
        if [ -f "process.log" ]; then
          cat process.log|puts_red_f
        fi
        exit 1;
    else
        puts_green "Success"
        exit 0;
    fi
}

ARGS=3

indent() {
    echo "       $@"
}

puts-step() {
    echo "-----> $@"
}

puts-step-sameline() {
    echo -n "-----> $@"
}

puts-warn() {
    echo " !     $@"
}

usage() {
    echo "Usage: $0 <user> <repo> <sha>"
}

parse-string(){
    # helper to avoid the single quote escape
    # occurred in command substitution
    local args=() idx=0 IFS=' ' c
    for c; do printf -v args[idx++] '%s ' "$c"; done
    printf "%s\n" "${args[*]}"
}

if [ $# -ne $ARGS ]; then
    usage
    exit 1
fi

USER=$1
REPO=$2
GIT_SHA=$3
SHORT_SHA=${GIT_SHA:0:8}
APP_NAME="${REPO%.*}"

cd $(dirname $0) # ensure we are in the root dir

ROOT_DIR=$(pwd)
DOCKERFILE_SHIM="/usr/local/share/shim.dockerfile"
REPO_DIR="${ROOT_DIR}/${REPO}"
BUILD_DIR="${REPO_DIR}/build"
CACHE_DIR="${REPO_DIR}/cache"

# define image names
IMAGE_NAME="$APP_NAME:git-$SHORT_SHA"
TMP_IMAGE="{{ getv "/deis/registry/host" }}:{{ getv "/deis/registry/port" }}/$IMAGE_NAME"

# create app directories
mkdir -p $BUILD_DIR $CACHE_DIR
# create temporary directory inside the build dir for this push
TMP_DIR=$(mktemp -d -p $BUILD_DIR)

cd $REPO_DIR
git archive $GIT_SHA | tar -xmC $TMP_DIR

# switch to app context
cd $TMP_DIR

USING_DOCKERFILE=false

if [ -f Dockerfile ]; then
    USING_DOCKERFILE=true
fi

# pull config from controller to be used during build
URL="{{ getv "/deis/controller/protocol" }}://{{ getv "/deis/controller/host" }}:{{ getv "/deis/controller/port" }}/v1/hooks/config"
RESPONSE=$(get-app-config -url="$URL" -key="{{ getv "/deis/controller/builderKey" }}" -user=$USER -app=$APP_NAME)
CODE=$?

if [ $CODE -ne 0 ]; then
    puts-warn $RESPONSE
    exit 1
fi

# if no Dockerfile is present, use slugbuilder to compile a heroku slug
# and write out a Dockerfile to use that slug
if [ ! -f Dockerfile ]; then
    STACK_NAME=$(echo $APP_NAME|awk -F- '{print $1}')
    BUILD_IMAGE="{{ getv "/deis/registry/host" }}:{{ getv "/deis/registry/port" }}/${STACK_NAME}-build"
    VERIFY_IMAGE="{{ getv "/deis/registry/host" }}:{{ getv "/deis/registry/port" }}/${STACK_NAME}-verify"

    echo
    puts-step "Starting Building ..."
    docker pull $BUILD_IMAGE &>process.log
    docker run --rm \
        --privileged \
        -v /var/run/docker.sock:/var/run/docker.sock \
        -v `pwd`:/codebase \
        -v $REPO_DIR:/gitbare:r \
        -v $CACHE_DIR:/build_cache \
        -e APP_NAME=$APP_NAME \
        -e STACK=$STACK_NAME \
        -e HOST=$HOST \
        -e IMAGE=$TMP_IMAGE $BUILD_IMAGE
    puts-step "Build $APP_NAME success"
    echo

    echo
    puts-step "Staring Verify $APP_NAME ..."
    docker pull $VERIFY_IMAGE &>process.log
    docker run --rm \
        --privileged \
        -v /var/run/docker.sock:/var/run/docker.sock \
        -v `pwd`:/codebase \
        -v $CACHE_DIR:/build_cache \
        -v $REPO_DIR:/gitbare:r \
        -e APP_NAME=$APP_NAME \
        -e STACK=$STACK_NAME \
        -e HOST=$HOST  $VERIFY_IMAGE
    puts-step "Verify $APP_NAME success"
    echo
else
    # force newline
    echo "" >> Dockerfile
    # inject builder-specific environment variables into the application environment
    echo "ENV GIT_SHA $GIT_SHA" >> Dockerfile
    docker build -t $TMP_IMAGE . 2>&1
fi

echo
puts-step "Pushing image to private registry"
docker push $TMP_IMAGE  &>process.log
puts-step "Push image success... "
echo

# use Procfile if provided, otherwise try default process types from ./release
if [ -f Procfile ]; then
    PROCFILE=$(cat Procfile | yaml2json-procfile)
elif [ -f $TMP_DIR/slug.tgz ]; then
    # Sometimes, the buildpack will generate a Procfile instead of populating /bin/release
    # /bin/release was unofficially deprecated for declaring default process types
    if tar -tzf $TMP_DIR/slug.tgz ./Procfile &> /dev/null;
    then
        PROCFILE="$(tar --to-stdout -xzf $TMP_DIR/slug.tgz ./Procfile | yaml2json-procfile)"
    else
        PROCFILE=$(tar --to-stdout -xzf $TMP_DIR/slug.tgz ./.release | extract-types)
    fi
else
    PROCFILE="{}"
fi

puts-step "Launching... "
URL="{{ getv "/deis/controller/protocol" }}://{{ getv "/deis/controller/host" }}:{{ getv "/deis/controller/port" }}/v1/hooks/build"
DATA=$(generate-buildhook "$SHORT_SHA" "$USER" "$APP_NAME" "$APP_NAME" "$PROCFILE" "true")
PUBLISH_RELEASE=$(echo "$DATA" | publish-release-controller -url=$URL -key={{ getv "/deis/controller/builderKey" }})

CODE=$?
if [ $CODE -ne 0 ]; then
    puts-warn "ERROR: Failed to launch container"
    puts-warn $PUBLISH_RELEASE
    exit 1
fi

RELEASE=$(echo $PUBLISH_RELEASE | extract-version)
DOMAIN=$(echo $PUBLISH_RELEASE | extract-domain)
indent "done, $APP_NAME:v$RELEASE deployed to Deis"
echo
indent "http://$DOMAIN"
echo
indent "To learn more, use \`deis help\` or visit http://deis.io"
echo

# cleanup
cd $REPO_DIR
git gc &>/dev/null
if [ -n "$JOB" ]; then
  docker rm -f $JOB &>/dev/null
fi
